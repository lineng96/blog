# 8. 线性时间排序
任何比较排序算法（如堆排序、快排、归并排序）在最坏情况下的下界都是 $\Omega(n\log n)$。为了突破限制，线性时间排序法利用输入数据的**特殊性质**（如数据范围、分布规律等）来决定元素的顺序。

## 8.1 计数排序
核心思想：**不比较、只计数**

对于每一个输入元素 $x$ ，确定小于 $x$ 的元素个数。利用这一信息，将 $x$ 放在输出数组的第 $k$ 个位置。

适用前提：
* 整数类型：输入的元素必须是整数。
* 范围有限：假设输入的 $n$ 个数都在 $0$ 到 $k$ 的范围内。当 $k = O(n)$ 时，排序的复杂度才是线性的$O(n)$ 。

步骤：

假设输入数组为 $A$ ，输出数组为 $B$ ，辅助存储空间为 $C$（长度为 $k + 1$）。 
1. **初始化**：将 $C$ 数组清零；
2. **计数**：遍历 $A$ ，统计每个值出现的次数。$C[i]$ 保存了值 $i$ 出现的频率；
3. **累加（计算前缀和）**：对 $C$ 进行累加运算，$C[i] = C[i] + C[i - 1]$ ，$C[i]$ 保存了小于或等于 $i$ 的元素个数；
4. **反向填充**：**从后往前**遍历 $A$ ，根据 $C$ 中的值将 $A[j]$ 放入 $B$ 的对应位置，每放一个 $C$ 中对应的计数 $- 1$ 。
```cpp
vector<int> countingSort(const vector<int> &A, const int k) {
    const int n = A.size();
    vector<int> B(n);
    vector C(k + 1, 0);

    // 1. 频率
    for (int j = 0; j < n; j++) {
        C[A[j]]++;
    }
    // 2.累加频率
    for (int i = 1; i <= k; i++) {
        C[i] += C[i - 1];
    }
    // 3.反向填充
    for (int j = n - 1; j >= 0; j--) {
        B[C[A[j]] - 1] = A[j];
        C[A[j]]--;
    }
    return B;
}
```
## 8.2 基数排序



